import { ConflictException, Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { User } from '../common/schema/user.schema';
import mongoose from 'mongoose';
import { UpdateUserDto } from './dto/update-user.dto';
import * as admin from 'firebase-admin';

@Injectable()
export class UserService {
  constructor(
    @InjectModel(User.name)
    private userModel: mongoose.Model<User>,
  ) {}
  async findAll(): Promise<User[]> {
    try {
      const users = await this.userModel
        .find({ isDeleted: { $ne: true } })
        .populate('auth');
      return users;
    } catch (err) {
      throw new ConflictException(err);
    }
  }

  async findOne(id: string): Promise<User | null> {
    const user = await this.userModel.findById(id).populate('auth');
    if (!user || user.isDeleted) {
      throw new ConflictException(`User with id ${id} not found`);
    }
    return user;
  }

  async updateUser(updateUserDto: UpdateUserDto, id: string): Promise<User> {
    try {
      const updatedUser = await this.userModel.findByIdAndUpdate(
        id,
        updateUserDto,
        { new: true },
      );
      return updatedUser;
    } catch (err) {
      throw new ConflictException(err);
    }
  }

  async deleteUser(id: string): Promise<void> {
    try {
      await this.userModel.findById(id);
    } catch (err) {
      throw new ConflictException(err);
    }
    await this.userModel.findByIdAndUpdate(
      id,
      { isDeleted: true },
      { new: true },
    );
  }

  async uploadImage(file: Express.Multer.File, req: Request): Promise<string> {
    try {
      const bucket = admin.storage().bucket('gs://exypnos-63ca1.appspot.com');
      const fileName = `${Date.now()}_${file.originalname}`;
      const fileUpload = bucket.file(`userImages/${fileName}`);

      const stream = fileUpload.createWriteStream({
        metadata: {
          contentType: file.mimetype,
        },
      });

      await new Promise<void>((resolve, reject) => {
        stream.on('error', (error) => {
          console.error('Error in stream:', error);
          reject(new ConflictException('Failed to upload file'));
        });

        stream.on('finish', resolve);
        stream.end(file.buffer);
      });

      await fileUpload.makePublic();
      const publicUrl = fileUpload.publicUrl();
      await this.userModel.findByIdAndUpdate(req['user'].sub, {
        imageUrl: publicUrl,
      });
      return publicUrl;
    } catch (error) {
      console.error('Error uploading file:', error);
      throw new ConflictException('Failed to upload file');
    }
  }


  async filterUsers(name: string): Promise<User[]> {
    try {
      const users = await this.userModel
        .find({
          firstName: { $regex: name, $options: 'i' },
          isDeleted: { $ne: true },
        })
      return users;
    } catch (err) {
      throw new ConflictException(err);
    }
  }

  async getAllUserWithAssets(): Promise<User[]> {
    try {
      const usersWithAsset = await this.userModel.aggregate(
          [
            {
              $lookup: {
                from: "assets",
                localField: "_id",
                foreignField: "userId",
                as: "assets"
              }
            },
            {
              $project: {
                _id: 1,
                firstName: 1,
                lastName: 1,
                assets:1
              }
            }
      ]);
      return usersWithAsset;

    } catch (err) {
      throw new ConflictException(err);
    }
  } 

  async getUserWithAssets(id: string): Promise<User> {
    const user = await this.userModel.findById(id).populate('auth');
    if (!user || user.isDeleted) {
      throw new ConflictException(`User with id ${id} not found`);
    }

    try {
      const userWithAsset = await this.userModel.aggregate(
          [
            {
              $match: {
                _id: new mongoose.Types.ObjectId(id)
              }
            },
            {
              $lookup: {
                from: "assets",
                localField: "_id",
                foreignField: "userId",
                as: "assets"
              }
            },
            {
              $project: {
                _id: 1,
                firstName: 1,
                lastName: 1,
                assets:1
              }
            }
      ]);
      return userWithAsset[0];

    } catch (err) {
      throw new ConflictException(err);
    }


}

}